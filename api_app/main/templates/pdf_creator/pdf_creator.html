{% extends 'base.html' %}
{% load static %}

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

{% block content %}
<body>

<div id="csrf-token" data-token="{{ csrf_token }}"></div>

<div class="offers__cont" id="of_cont">
    <div class="container_editor">
        <!-- Square form for image upload -->
        <div class="square-form">
            <form id="imageForm" method="POST" enctype="multipart/form-data">
                {% csrf_token %}
                <input type="file" name="image" id="image" required style="display:none;">
                <button type="button" id="triggerFileInput">Add Image</button>
            </form>
        </div>

        <!-- Add text button -->
        <button id="addText">Add Text</button>
    </div>

    <div id="PDFArea"></div>

    <button id="downloadCombined" style="margin-top: 20px;">Download Combined Image</button>

    <canvas id="combinedCanvas" style="display:none;"></canvas> <!-- Hidden Canvas for combining images and text -->
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/axios/1.6.8/axios.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>


<script>
    const form = document.getElementById('imageForm');
    const inputFile = document.getElementById('image');
    const triggerFileInput = document.getElementById('triggerFileInput');
    const PDFArea = document.getElementById('PDFArea');
    const downloadCombined = document.getElementById('downloadCombined');
    const combinedCanvas = document.getElementById('combinedCanvas');
    let draggedItem = null;

    // Open the file dialog when the button is clicked
    triggerFileInput.addEventListener('click', () => {
        inputFile.click();
    });

    // Handle image upload
    inputFile.addEventListener('change', () => {
        if (inputFile.files.length > 0) {
            const reader = new FileReader();
            reader.onload = function (event) {
                const resizableContainer = document.createElement('div');
                resizableContainer.classList.add('resizable');
                resizableContainer.style.width = '300px';  // Initial width
                resizableContainer.style.height = '300px'; // Initial height

                const imgElement = document.createElement('img');
                imgElement.src = event.target.result;
                // imgElement.style.position 
                resizableContainer.appendChild(imgElement);

                addResizeHandlers(resizableContainer);
                addDragDropLogic(resizableContainer);

                PDFArea.appendChild(resizableContainer);
            };
            reader.readAsDataURL(inputFile.files[0]);
        }
    });

    // Add resize handles to the element
    function addResizeHandlers(element) {
        const tl = document.createElement('div');
        tl.classList.add('resize-handle', 'tl');
        const tr = document.createElement('div');
        tr.classList.add('resize-handle', 'tr');
        const bl = document.createElement('div');
        bl.classList.add('resize-handle', 'bl');
        const br = document.createElement('div');
        br.classList.add('resize-handle', 'br');

        element.appendChild(tl);
        element.appendChild(tr);
        element.appendChild(bl);
        element.appendChild(br);

        let startX, startY, startWidth, startHeight;

        [tl, tr, bl, br].forEach(handle => {
            handle.addEventListener('mousedown', function (e) {
                e.preventDefault();
                startX = e.clientX;
                startY = e.clientY;
                startWidth = parseInt(window.getComputedStyle(element).width, 10);
                startHeight = parseInt(window.getComputedStyle(element).height, 10);

                function resizeElement(event) {
                    if (handle === tl || handle === bl) {
                        element.style.width = `${startWidth - (event.clientX - startX)}px`;
                    } else {
                        element.style.width = `${startWidth + (event.clientX - startX)}px`;
                    }

                    if (handle === tl || handle === tr) {
                        element.style.height = `${startHeight - (event.clientY - startY)}px`;
                    } else {
                        element.style.height = `${startHeight + (event.clientY - startY)}px`;
                    }
                }

                document.addEventListener('mousemove', resizeElement);
                document.addEventListener('mouseup', function stopResize() {
                    document.removeEventListener('mousemove', resizeElement);
                    document.removeEventListener('mouseup', stopResize);
                });
            });
        });
    }

    // Add drag-and-drop logic to the element
    function addDragDropLogic(element) {
        let isDragging = false;
        let startX, startY;

        element.addEventListener('mousedown', (e) => {
            isDragging = true;
            startX = e.clientX - parseInt(element.style.left || 0, 10);
            startY = e.clientY - parseInt(element.style.top || 0, 10);
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                element.style.left = `${e.clientX - startX}px`;
                element.style.top = `${e.clientY - startY}px`;
            }
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
        });
    }

   // Adding text to the thumbnail area
        document.getElementById('addText').addEventListener('click', () => {
            const textElement = document.createElement('div');
            textElement.classList.add('resizable-text');
            textElement.innerText = "Napisz coÅ›...";
            textElement.style.width = '200px';
            textElement.style.height = '50px';
            textElement.style.padding = '10px';
            textElement.style.fontSize = '20px';
            textElement.style.backgroundColor = '#ffffe0';
            textElement.style.border = '1px solid #000';
            textElement.style.position = 'absolute'; // Ensure it can be positioned freely
            textElement.style.left = '0px';
            textElement.style.top = '0px';
            textElement.contentEditable = true; // Start with text editable

            // Ensure text wraps within the div and doesn't overflow
            textElement.style.overflow = 'hidden'; 
            textElement.style.wordWrap = 'break-word'; 
            textElement.style.whiteSpace = 'pre-wrap';

            // Add drag and resize logic
            addResizeHandlers(textElement);
            addDragDropLogic(textElement);

            // Append to thumbnail area
            PDFArea.appendChild(textElement);

            // Toggle editable mode on double-click
            textElement.addEventListener('click', () => {
                textElement.contentEditable = true;
                textElement.focus(); // Focus the text element when double-clicked              
            });

            // Set contentEditable to false when clicking outside the text element
            document.addEventListener('click', (e) => {
                if (e.target !== textElement && textElement.contentEditable === 'true') {
                    textElement.contentEditable = false;
                }
            });
        });


        // const canvasWidth = 2480;
        // const canvasHeight = 3508;

        // Combine images and text inside the PDFArea and download the result
        downloadCombined.addEventListener('click', function () {

            const items = PDFArea.querySelectorAll('.resizable, .resizable-text');
            if (items.length === 0) {
                alert("No items to combine!");
                return;
            }

            const canvasWidth = 1193;  // Set the desired canvas size in pixels
            const canvasHeight = 1680;
            combinedCanvas.width = canvasWidth;
            combinedCanvas.height = canvasHeight;

            const ctx = combinedCanvas.getContext('2d');
            ctx.clearRect(0, 0, canvasWidth, canvasHeight); // Clear the canvas

            let imagesLoaded = 0;  // Counter for loaded images
            const totalItems = items.length;  // Total items to be drawn

            items.forEach(item => {

                const xPos = parseInt(item.style.left) || 0;
                const yPos = parseInt(item.style.top) || 0;

                if (item.tagName === 'DIV' && item.classList.contains('resizable-text')) {
                    // Handle text rendering
                    const fontSize = parseInt(item.style.fontSize) || 20;
                    ctx.font = `${fontSize}px sans-serif`;
                    ctx.fillStyle = '#000'; // Text color

                    const maxWidth = item.offsetWidth; // Width of the container for the text
                    const text = item.innerText;
                    const lineHeight = fontSize * 1.2;

                    // Function to split text into multiple lines based on maxWidth
                    function wrapText(context, text, x, y, maxWidth, lineHeight) {
                        const words = text.split(' ');
                        let line = '';
                        let lines = [];
                        for (let n = 0; n < words.length; n++) {
                            const testLine = line + words[n] + ' ';
                            const metrics = context.measureText(testLine);
                            const testWidth = metrics.width;
                            if (testWidth > maxWidth && n > 0) {
                                lines.push(line); // Push the current line
                                line = words[n] + ' '; // Start a new line
                            } else {
                                line = testLine;
                            }
                        }
                        lines.push(line); // Push the last line

                        // Draw each line on the canvas
                        lines.forEach((lineText, index) => {
                            context.fillText(lineText, x, y + (index * lineHeight));
                        });
                    }

                    wrapText(ctx, text, xPos, yPos, maxWidth, lineHeight); // Wrap and render text

                    // textLines.forEach((line, index) => {
                    //     // ctx.fillText(line, xPos, yPos + (index * lineHeight) + lineHeight); // Draw each line of text
                    //     ctx.fillText(line, xPos, yPos + (index * lineHeight) + lineHeight);
                    // });

                    imagesLoaded += 1;

                } else if (item.querySelector('img')) {
                    const imgElement = new Image();
                    imgElement.src = item.querySelector('img').src;

                    imgElement.onload = function () {
                        const containerWidth = item.offsetWidth;
                        const containerHeight = item.offsetHeight;

                        // Draw image onto canvas at the calculated position and size
                        ctx.drawImage(imgElement, xPos, yPos, containerWidth, containerHeight);

                        imagesLoaded += 1; // Increment loaded images count

                        if (imagesLoaded === totalItems) { // Check if all images are loaded
                            triggerDownload(); // Trigger download only if all images are loaded
                        }
                    };

                    imgElement.onerror = function () {
                        console.error("Failed to load image:", imgElement.src);
                        imagesLoaded++; // Increment anyway to prevent hanging
                        if (imagesLoaded === totalItems) {
                            triggerDownload(); // Trigger download even if some images failed
                        }
                    };

                } else {
                    imagesLoaded += 1; // Increment for non-image items to prevent hanging
                }
            });

            function triggerDownload() {
                console.log('triggerDownload');
                const { jsPDF } = window.jspdf; // Access jsPDF
                const pdf = new jsPDF('p', 'px', [1193, 1680]); // Create a new jsPDF instance using pixel size (A4 at 300 DPI)

                // Convert canvas to image and add it to the PDF
                const canvasImage = combinedCanvas.toDataURL("image/png"); // Convert canvas to PNG
                pdf.addImage(canvasImage, 'PNG', 0, 0, 1193, 1680); // Add the canvas image to the PDF, scaled to A4 size in pixels
                pdf.save('combined_image.pdf'); // Save the PDF
            }

        });



</script>

</body>
{% endblock %}
</html>