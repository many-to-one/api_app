{% extends 'base.html' %}
{% load static %}

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

{% block content %}
<body>

    <div id="csrf-token" data-token="{{ csrf_token }}"></div>

    <div class="offers__cont" id="of_cont">

        <div class="container_editor">
            <div class="square-form">
                <form id="imageForm" method="POST" enctype="multipart/form-data">
                    {% csrf_token %}
                    <input type="file" name="image" id="image" required style="display:none;">
                    <button type="button" id="triggerFileInput">+</button>
                </form>
                <!-- Spinner -->
                <div class="d-flex justify-content-center">
                    <div class="spinner-border" role="status" id="spinner">
                    <span class="visually-hidden">Loading...</span>
                    </div>
                </div>
            </div>
            <!-- Placeholder for the processed image -->
            <div id="result">
                <!-- <img id="outputImage" src="" style="display:none;" alt="Processed Image" width="300"> -->
                <!-- <a id="downloadLink" href="" download="processed_image.png" style="display:none;">
                    pobierz
                </a> -->
            </div>
        </div>

        <label for="customRange2" class="form-label">Granica maski</label>
        <!-- Display the range value -->
        <p id="rangeValueDisplay">0</p>
        <input type="range" class="form-range" min="0" max="255" id="threshold" onchange="getRangeValue()">

        <div id="navProImg" class="d-flex justify-content-between">
            <img style="cursor: pointer;" src="{% static 'icons/rotate.svg' %}" width="25" alt="">
            <img id="curve" onclick="applyCurvedEffect()" style="cursor: pointer;" src="{% static 'icons/curve.svg' %}" width="25" alt="">
            <img style="cursor: pointer;" src="{% static 'icons/copy.svg' %}" width="25" alt="">
            <img style="cursor: pointer;" src="{% static 'icons/close.svg' %}" width="25" alt="">
        </div>

        <canvas id="curvedCanvas" width="500" height="500" style="display: none;"></canvas>
        <img id="imageToCurve" style="display:none;">

        <div id="thumbnailArea" class="d-flex justify-content-center align-items-center">
            <svg xmlns="http://www.w3.org/2000/svg" width="50" fill="currentColor" class="bi bi-images" viewBox="0 0 16 16" opacity="0.2">
              <path d="M4.502 9a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3"/>
              <path d="M14.002 13a2 2 0 0 1-2 2h-10a2 2 0 0 1-2-2V5A2 2 0 0 1 2 3a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v8a2 2 0 0 1-1.998 2M14 2H4a1 1 0 0 0-1 1h9.002a2 2 0 0 1 2 2v7A1 1 0 0 0 15 11V3a1 1 0 0 0-1-1M2.002 4a1 1 0 0 0-1 1v8l2.646-2.354a.5.5 0 0 1 .63-.062l2.66 1.773 3.71-3.71a.5.5 0 0 1 .577-.094l1.777 1.947V5a1 1 0 0 0-1-1z"/>
            </svg>
        </div>
        <button id="downloadCombined" style="margin: 20px;" type="button" class="btn btn-primary">Zapisz</button>

        <canvas id="combinedCanvas" style="display:none;"></canvas> <!-- Hidden Canvas for combining images -->
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/1.6.8/axios.min.js"></script>

    <!-- JIMP - IMAGE MANIPULATIO LIBRARY -->
    <script src="https://cdn.jsdelivr.net/npm/jimp@1.6.0/dist/commonjs/index.min.js"></script> 


    <script>
        const csrfToken = document.getElementById('csrf-token').getAttribute('data-token');
        const form = document.getElementById('imageForm');
        const inputFile = document.getElementById('image');
        const threshold_ = document.getElementById('threshold');
        const triggerFileInput = document.getElementById('triggerFileInput');
        const spinner = document.getElementById('spinner');
        const thumbnailArea = document.getElementById('thumbnailArea');
        const downloadCombined = document.getElementById('downloadCombined');
        const combinedCanvas = document.getElementById('combinedCanvas');
        const imageNavCont = document.getElementById('navProImg');

        const curveIcon = document.getElementById('curve');
        let draggedImage = null;
        let isActiveImage = false;
        let imageName = null;
        let imagURL = null
        let activeImage = null;


        // function applyCurvedEffect() {
        //     applyCurvingToImage();
        // }


        // Function to curve the image
        function applyCurvedEffect() {
            // Get the existing canvas element
            const curvedCanvas = document.getElementById('curvedCanvas');
            const ctx = curvedCanvas.getContext('2d');

            // Get the image element by class name (or id)
            const imgElement = document.getElementsByClassName('imgElement_IMG_5615.JPG')[0]; // Get the first element

            if (!imgElement) {
                console.error('Image element not found');
                return;
            }

            console.log('applyCurvedEffect - imgElement', imgElement);

            // Set canvas dimensions to match the image
            curvedCanvas.width = imgElement.width;
            curvedCanvas.height = imgElement.height;

            // Create a new image object and set its source to the existing image's source
            const img = new Image();
            img.src = imgElement.src;

            // Wait until the image has loaded before drawing
            img.onload = function () {
                // Draw the image on the canvas first
                ctx.drawImage(img, 0, 0, imgElement.width, imgElement.height);

                // Apply the curve processing logic here
                const curveIntensity = 0.05; // Adjust for curve intensity
                const curveOffset = 50; // Adjust for curve depth

                const width = imgElement.width;
                const height = imgElement.height;

                // Apply curving effect row by row
                for (let y = 0; y < height; y++) {
                    const offset = Math.sin(y * curveIntensity) * curveOffset;
                    ctx.drawImage(img, 0, y, width, 1, offset, y, width, 1); // Draw each row with an offset
                }

                // Now replace the original image's src with the curved image from the canvas
                imgElement.src = curvedCanvas.toDataURL(); // Get the base64 image data
                console.log('Curved image applied successfully');
            };

            // If the image fails to load
            img.onerror = function () {
                console.error('Error loading the image for curving.');
            };
        }




        const resultCont = document.getElementById('result');
        resultCont.style.display = 'flex';

        // GET TRASHOLD VALUE
        window.onload = function() {
            // Set the initial value to 0 when the page loads
            const rangeInput = document.getElementById('threshold');
            rangeInput.value = 0; // Set the default value

            // Display the initial value
            document.getElementById('rangeValueDisplay').innerText = rangeInput.value;
        };
        function getRangeValue() {

            // Get the value of the range input
            const rangeValue = threshold_.value;

            // Display the value in a <p> element or use it in your logic
            document.getElementById('rangeValueDisplay').innerText = rangeValue;
        }



        triggerFileInput.addEventListener('click', () => {
            inputFile.click(); // Trigger file input click
        });

        inputFile.addEventListener('change', () => {
            if (inputFile.files.length > 0) {
                spinner.style.display = 'block';
                const formData = new FormData(form);
                // const threshold = rangeValue;
                console.log('formData', formData)
                formData.append('threshold', threshold_.value);

                axios.post("{% url 'remove_bg' %}", formData, {
                    headers: {
                        'X-CSRFToken': csrfToken,
                        'Content-Type': 'multipart/form-data',
                    }
                })
                .then(response => {
                    spinner.style.display = 'none';
                    if (response.data.success) {

                        imageName = response.data.imgName;
                        imagURL = response.data.image_data_url
                        workWithImage (imageName, imagURL);
                        
                    } else {
                        alert('Failed to process the image.');
                    }
                })
                .catch(error => {
                    spinner.style.display = 'none';
                    console.error('Error:', error);
                    alert('An error occurred. Please try again.');
                });
            
            }
        });


        function workWithImage (imageName, imagURL) {
                        activeImage = imageName

                        // logic to download result in original size
                        const outputImage = document.createElement('img'); //document.getElementById('outputImage');
                        outputImage.src = imagURL;
                        outputImage.style.display = 'block';
                        outputImage.style.width = '150px';

                        outputImage.onclick = function () {
                            // Get all images within the same container and remove the 'activeImage' class
                            const allImages = resultCont.querySelectorAll('img');
                            allImages.forEach(img => img.classList.remove('activeImage'));

                            // Add the 'activeImage' class only to the clicked image
                            outputImage.classList.add('activeImage');
                        }

                        const downloadLink = document.createElement('a'); //document.getElementById('downloadLink');
                        downloadLink.href = imagURL; //response.data.image_data_url;
                        downloadLink.download = "processed_image.png";
                        downloadLink.style.display = 'block';
                        const uploadImg = document.createElement('img');
                        uploadImg.src = "{% static 'icons/upload.svg' %}";
                        downloadLink.appendChild(uploadImg);

                        resultCont.appendChild(outputImage);
                        resultCont.appendChild(downloadLink);

                        // logic for create a thumbnail
                        const resizableContainer = document.createElement('div');
                        resizableContainer.classList.add('resizable');
                        resizableContainer.style.width = '300px';  // Initial width
                        resizableContainer.style.height = '300px'; // Initial height

                        const imgElement = document.createElement('img');
                        imgElement.src = imagURL; //response.data.image_data_url;
                        imgElement.setAttribute('data-index', imageName);
                        imgElement.classList.add('imgElement_' + imageName);

                        imgElement.onclick = function () {

                            console.log('isActiveImage', isActiveImage)

                            const imgIndex = this.getAttribute('data-index');
                            console.log('onclick imgIndex', imgIndex);

                            activeImage = imgIndex

                            if ( isActiveImage === true ) {
                                setInactiveImg(imgIndex);
                            } else {
                                setActiveImg(imgIndex);
                            }
                            
                            // resizeImage(imgIndex);  // Pass the index to the resizeImage function
                        }
                        resizableContainer.appendChild(imgElement);

                        // // Add resize handles for all corners
                        const handles = ['tl', 'tr', 'bl', 'br'];
                        handles.forEach(handle => {
                            const resizeHandle = document.createElement('div');
                            resizeHandle.setAttribute('data-index', imageName);
                            resizeHandle.classList.add('resize-handle', handle);
                            resizableContainer.appendChild(resizeHandle);
                        });


                        function setInactiveImg(imgIndex) {
                            resizableContainer.style.border = 'none';
                            const resizeHandle = document.querySelectorAll('.resize-handle');
                            resizeHandle.forEach(handler => handler.style.display = 'none');

                            // Hide the rotation handle
                            const rotationHandle = document.getElementsByClassName('rotate-handle_' + imageName);
                            console.log('setInactiveImg - rotationHandle', rotationHandle);
                            
                            if (rotationHandle.length > 0) { // Check if there is a rotation handle
                                Array.from(rotationHandle).forEach(handler => handler.style.display = 'none');
                            }

                            isActiveImage = false;
                        }

                        function setActiveImg(imgIndex) {
                            resizableContainer.style.border = 'block';
                            const resizeHandle = document.querySelectorAll('.resize-handle');
                            resizeHandle.forEach(handler => handler.style.display = 'block');
                            isActiveImage = true;
                            resizeImage(imgIndex);
                            startRotate(imageName);
                        }

                        function resizeImage(imgIndex) {
                            console.log('imgIndex', imgIndex);

                            // Apply a border to the container
                            resizableContainer.style.border = '2px dashed gray';

                            // Get all resize handles
                            const resizeHandles = document.querySelectorAll('.resize-handle');

                            resizeHandles.forEach((handler, index) => {
                                // console.log('handler', handler);

                                const dataIndex = handler.getAttribute('data-index');
                                // console.log('dataIndex', dataIndex);

                                // Show the handler if the index matches, otherwise hide it
                                if (dataIndex === imgIndex) {
                                    handler.style.display = 'block';
                                } else {
                                    handler.style.display = 'none';
                                }
                            });
                        }


                        // // Function to curve the image
                        // function applyCurvingToImage() {
                        //     const canvas = document.createElement('canvas');
                        //     const ctx = canvas.getContext('2d');

                        //     // Set canvas dimensions to match image
                        //     canvas.width = imgElement.width;
                        //     canvas.height = imgElement.height;

                        //     // Apply the curve processing logic here
                        //     const curveIntensity = 0.05; // Adjust for curve intensity
                        //     const curveOffset = 20; // Adjust for curve depth

                        //     const width = imgElement.width;
                        //     const height = imgElement.height;

                        //     // Draw the image on the canvas with curving effect
                        //     const img = new Image();
                        //     img.src = imgElement.src;

                        //     img.onload = function () {
                        //         for (let y = 0; y < height; y++) {
                        //             const offset = Math.sin(y * curveIntensity) * curveOffset;
                        //             ctx.drawImage(img, 0, y, width, 1, offset, y, width, 1); // Draw each row with offset
                        //         }

                        //         // Replace the image with the canvas containing the curved image
                        //         imgElement.src = canvas.toDataURL();
                        //     };
                        // }


                        // SHOW MENU
                        const properCont = document.createElement('div');
                        properCont.classList.add('pr');
                        let menuActive = false;

                        properCont.onclick = function() { 
                            console.log('menuActive', menuActive)

                            if ( menuActive === false) {
                                console.log('menuActive show', menuActive)
                                const menuCont = document.createElement('div');
                                menuCont.classList.add('menuActive')
                                menuCont.style.display = 'flex';
                                menuCont.style.flexDirection = 'column';
                        
                                const icons = ['close'];
                                    icons.forEach(icon => {
                                    const resizeHandle = document.createElement('div');
                                    resizeHandle.classList.add(icon);
                                    menuCont.appendChild(resizeHandle);
                                });

                                resizableContainer.appendChild(menuCont);
                                menuActive = true;
                            } else {
                                console.log('menuActive none', menuActive)
                                const menuCont = document.getElementsByClassName('menuActive') //[0]; // Get the first element with the class 'menuActive'

                                menuCont.forEach(elem => {
                                    elem.style.display = 'none';  // Hide the menu
                                    menuActive = false;
                                })
        
                            }
                        };

                        resizableContainer.appendChild(properCont);
                        // END SHOW MENU

                        let isResizing = false;
                        let isDragging = false;
                        let isRotating = false; // New flag for rotation
                        let currentHandle = null;
                        let startX, startY, startWidth, startHeight, startLeft, startTop;
                        let startRotation = 0; // To store the initial rotation angle
                        let centerX, centerY; // Center of the element for rotation

                        // Function to rotate the element
                        function handleRotation(event) {
                            const dx = event.clientX - centerX;
                            const dy = event.clientY - centerY;
                            const angle = Math.atan2(dy, dx) * (180 / Math.PI); // Calculate angle in degrees
                            const rotationAngle = angle - startRotation; // Calculate relative angle
                            resizableContainer.style.transform = `rotate(${rotationAngle}deg)`;
                        }

                        // Function to resize the element
                        function handleResize(event, direction) {
                            const dx = event.clientX - startX;
                            const dy = event.clientY - startY;

                            if (direction.includes('r')) {
                                resizableContainer.style.width = `${startWidth + dx}px`;
                            } else if (direction.includes('l')) {
                                resizableContainer.style.width = `${startWidth - dx}px`;
                                resizableContainer.style.left = `${startLeft + dx}px`;
                            }

                            if (direction.includes('b')) {
                                resizableContainer.style.height = `${startHeight + dy}px`;
                            } else if (direction.includes('t')) {
                                resizableContainer.style.height = `${startHeight - dy}px`;
                                resizableContainer.style.top = `${startTop + dy}px`;
                            }
                        }

                        // Add resize handles
                        resizableContainer.querySelectorAll('.resize-handle').forEach(handle => {
                            handle.addEventListener('mousedown', function (event) {
                                isResizing = true;
                                currentHandle = handle.classList[1]; // e.g., 'tl', 'tr', etc.
                                startX = event.clientX;
                                startY = event.clientY;
                                startWidth = resizableContainer.offsetWidth;
                                startHeight = resizableContainer.offsetHeight;
                                startLeft = resizableContainer.offsetLeft;
                                startTop = resizableContainer.offsetTop;
                                event.preventDefault();
                            });
                        });

                        function startRotate(imageName) {
                            // Add rotation handle (for example, top-center)
                            const rotationHandle = document.createElement('div');
                            rotationHandle.classList.add('rotate-handle_' + imageName);
                            rotationHandle.style.display = 'block';
                            rotationHandle.style.position = 'absolute';
                            rotationHandle.style.top = '-20px'; // Place it above the container
                            rotationHandle.style.left = '-10px';
                            rotationHandle.style.transform = 'translateX(-50%)';
                            rotationHandle.style.cursor = 'grab';
                            rotationHandle.style.backgroundImage = 'url(/static/icons/rotate_in.svg)';
                            rotationHandle.style.width = '15px';
                            rotationHandle.style.height = '15px';
                            resizableContainer.appendChild(rotationHandle);

                            // Enable rotation on mouse down
                            rotationHandle.addEventListener('mousedown', function (event) {
                                isRotating = true;
                                const rect = resizableContainer.getBoundingClientRect();
                                centerX = rect.left + rect.width / 2; // Find the center of the container
                                centerY = rect.top + rect.height / 2;
                                startX = event.clientX;
                                startY = event.clientY;
                                startRotation = Math.atan2(startY - centerY, startX - centerX) * (180 / Math.PI);
                                event.preventDefault();
                            });
                        }

                        // Enable dragging for the resizable container
                        resizableContainer.addEventListener('mousedown', function (event) {
                            if (!isResizing && !isRotating) {
                                isDragging = true;
                                startX = event.clientX - resizableContainer.offsetLeft;
                                startY = event.clientY - resizableContainer.offsetTop;
                            }
                        });

                        document.addEventListener('mousemove', function (event) {
                            if (isResizing) {
                                handleResize(event, currentHandle);
                            } else if (isDragging) {
                                resizableContainer.style.left = `${event.clientX - startX}px`;
                                resizableContainer.style.top = `${event.clientY - startY}px`;
                            } else if (isRotating) {
                                handleRotation(event);
                            }
                        });

                        document.addEventListener('mouseup', function () {
                            isResizing = false;
                            isDragging = false;
                            isRotating = false;
                        });


                        thumbnailArea.appendChild(resizableContainer);
                        // isActiveImage = false;
        }
    

        thumbnailArea.addEventListener('dragover', function (event) {
            event.preventDefault();
        });

        // Function to combine images inside the thumbnailArea and download the result
        downloadCombined.addEventListener('click', function () {

            const resizableContainers = thumbnailArea.querySelectorAll('.resizable');
            if (resizableContainers.length === 0) {
                alert("No images to combine!");
                return;
            }

            // Set the canvas dimensions
            const canvasWidth = 2560;
            const canvasHeight = 2560;
            combinedCanvas.width = canvasWidth;
            combinedCanvas.height = canvasHeight;

            const ctx = combinedCanvas.getContext('2d');
            ctx.clearRect(0, 0, canvasWidth, canvasHeight); // Clear canvas

            let imagesLoaded = 0;

            // Helper function to trigger download after all images are drawn
            function checkAllImagesLoaded() {
                if (imagesLoaded === resizableContainers.length) {
                    combinedCanvas.toBlob(function (blob) {
                        const downloadLink = document.createElement('a');
                        downloadLink.href = URL.createObjectURL(blob);
                        downloadLink.download = 'combined_image.png';
                        downloadLink.click();
                    }, 'image/png');
                }
            }

            // Draw each image on the canvas in the right size and position
            resizableContainers.forEach(container => {
                const img = container.querySelector('img');
                const left = parseInt(container.style.left) || 0;
                const top = parseInt(container.style.top) || 0;
                // const containerWidth = container.offsetWidth;
                // const containerHeight = container.offsetHeight;

                // Create a new image object to ensure it's loaded properly
                const imgElement = new Image();
                imgElement.src = img.src;

                imgElement.onload = function () {

                    const containerWidth = container.offsetWidth; // Width of the container
                    const containerHeight = container.offsetHeight;

                    // Calculate aspect ratio and fit image within the container's size
                    const originalWidth = imgElement.naturalWidth;
                    const originalHeight = imgElement.naturalHeight;
                    const aspectRatio = originalWidth / originalHeight;

                    // Determine the correct drawing size and position to maintain aspect ratio
                    let drawWidth, drawHeight;
                    if (containerWidth / containerHeight > aspectRatio) {
                        drawHeight = containerHeight;
                        drawWidth = drawHeight * aspectRatio;
                    } else {
                        drawWidth = containerWidth;
                        drawHeight = drawWidth / aspectRatio;
                    }

                    // Calculate scale factor based on canvas size change
                    const scaleFactor = canvasWidth / 500; // Assuming original canvas was 1000x1000
                    const scaledWidth = drawWidth * scaleFactor;
                    const scaledHeight = drawHeight * scaleFactor;

                    // Calculate the final position on the canvas using the image's own position
                    const drawX = (left + (containerWidth - drawWidth) / 2) * scaleFactor; // Centering the image
                    const drawY = (top + (containerHeight - drawHeight) / 2) * scaleFactor; // Centering the image   
                    
                    // Draw the image onto the canvas at the calculated position and size
                    ctx.drawImage(imgElement, drawX, drawY, scaledWidth, scaledHeight);

                    imagesLoaded++;  // Increment the count of loaded images
                    checkAllImagesLoaded();  // Check if all images are loaded and drawn
                };
                    });
                });
    </script>

</body>
{% endblock %}
</html>