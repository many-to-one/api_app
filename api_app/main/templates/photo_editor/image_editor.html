{% extends 'base.html' %}
{% load static %}

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

{% block content %}
<body>

    <div id="csrf-token" data-token="{{ csrf_token }}"></div>

    <div class="offers__cont" id="of_cont">

        <div class="container_editor">
            <div class="square-form">
                <form id="imageForm" method="POST" enctype="multipart/form-data">
                    {% csrf_token %}
                    <input type="file" name="image" id="image" required style="display:none;">
                    <button type="button" id="triggerFileInput">+</button>
                </form>
                <!-- Spinner -->
                <div class="d-flex justify-content-center">
                    <div class="spinner-border" role="status" id="spinner">
                    <span class="visually-hidden">Loading...</span>
                    </div>
                </div>
            </div>
            <!-- Placeholder for the processed image -->
            <div id="result"></div>
        </div>

        <label for="customRange2" class="form-label">Granica maski</label>
        <!-- Display the range value -->
        <p id="rangeValueDisplay">0</p>
        <input type="range" class="form-range" min="0" max="255" id="threshold" onchange="getRangeValue()">

        <div id="navProImg" class="d-flex justify-content-between">
            <img style="cursor: pointer;" src="{% static 'icons/rotate.svg' %}" width="25" alt="">
            <img id="brightness" onclick="showProcContainer()" style="cursor: pointer;" src="{% static 'icons/curve.svg' %}" width="25" alt="">
            <img id="duplicateImg" onclick="duplicateImg()" style="cursor: pointer;" src="{% static 'icons/copy.svg' %}" width="25" alt="">
            <img id="duplicateImg" onclick="showShadowContainer()" style="cursor: pointer;" src="{% static 'icons/options.svg' %}" width="25" alt="">
            <img style="cursor: pointer;" onclick="deleteImg()" src="{% static 'icons/close.svg' %}" width="25" alt="">
            <img style="cursor: pointer;" onclick=" isDraw__()" src="{% static 'icons/close.svg' %}" width="25" alt="">
        </div>

        <!-- TEST BRIGHTNESS CONTAINER 1 -->
        <canvas id="curvedCanvas" width="500" height="500" style="display: none;"></canvas>
        <img id="imageToCurve" style="display:none;">

        <!-- TEST BRIGHTNESS CONTAINER 2 -->
        <div id="procContainer" class="proContainer" style="display: none;">     
            <div class="slider-container d-flex justify-content-evenly gap-5">
                <label for="brightnessSlider">Ekspozycja</label>
                <input type="range" id="brightnessSlider" class="slider" min="0" max="2" step="0.1" value="1">
            </div>
            <div class="slider-container d-flex justify-content-evenly gap-5">
                <label for="redSlider">Czerwony</label>
                <input type="range" id="redSlider" class="slider" min="0" max="2" step="0.1" value="1">
            </div>
            <div class="slider-container d-flex justify-content-evenly gap-5">
                <label for="greenSlider">Zielony</label>
                <input type="range" id="greenSlider" class="slider" min="0" max="2" step="0.1" value="1">
            </div>
            <div class="slider-container d-flex justify-content-evenly gap-5">
                <label for="blueSlider">Niebieski</label>
                <input type="range" id="blueSlider" class="slider" min="0" max="2" step="0.1" value="1">
            </div>
            <div class="slider-container">
                <label for="contrastSlider">Kontrast</label>
                <input type="range" id="contrastSlider" class="slider" min="-100" max="150" step="1" value="0">
            </div>
            <div class="slider-container d-flex justify-content-evenly gap-5 mt-4">
                <img class="set__tooltip" popovertarget="makeCopy" id="makeCopyIcon" onclick="makeCopy()" style="cursor: pointer;" src="{% static 'icons/copy.svg' %}" width="15" alt="">
                <span class="tooltip__text">Kopiuj ustawienia</span>
                <img class="set__tooltip" popovertarget="addCopy" id="addCopyIcon" onclick="addCopy()" style="cursor: pointer;" src="{% static 'icons/paste.svg' %}" width="15" alt="">
                <span class="tooltip__text">Wklej</span>
            </div>
        </div>


         <!-- TEST shadow CONTAINER  -->
         <div id="shadowContainer" class="proContainer" style="display: none;">     
            <div class="slider-container d-flex justify-content-evenly gap-5">
                <label for="brightnessSlider">Cień</label>
                <img id="duplicateImg" onclick="addShadow()" style="cursor: pointer;" src="{% static 'icons/shadow.svg' %}" width="25" alt="">
            </div>
            <div class="slider-container d-flex justify-content-evenly gap-5">
                <label for="brightnessSlider">Odbij poziomo</label>
                <img id="duplicateImg" onclick="horizontalTurn()" style="cursor: pointer;" src="{% static 'icons/shadow.svg' %}" width="25" alt="">
            </div>
            <div class="slider-container d-flex justify-content-evenly gap-5">
                <label for="brightnessSlider">Odbij pionowo</label>
                <img id="duplicateImg" onclick="verticalFlip()" style="cursor: pointer;" src="{% static 'icons/shadow.svg' %}" width="25" alt="">
            </div>
            <div class="slider-container d-flex justify-content-evenly gap-5">
                <label for="brightnessSlider">Lustrzane odbicie</label>
                <img id="duplicateImg" onclick="addGrad()" style="cursor: pointer;" src="{% static 'icons/shadow.svg' %}" width="25" alt="">
            </div>


                
                
        </div>



        <div id="thumbnailArea" class="d-flex justify-content-center align-items-center">
            <canvas class="resizable" id="selectionCanvas" width="300" height="300" style="display: none;"></canvas>
            <svg xmlns="http://www.w3.org/2000/svg" width="50" fill="currentColor" class="bi bi-images" viewBox="0 0 16 16" opacity="0.2">
              <path d="M4.502 9a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3"/>
              <path d="M14.002 13a2 2 0 0 1-2 2h-10a2 2 0 0 1-2-2V5A2 2 0 0 1 2 3a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v8a2 2 0 0 1-1.998 2M14 2H4a1 1 0 0 0-1 1h9.002a2 2 0 0 1 2 2v7A1 1 0 0 0 15 11V3a1 1 0 0 0-1-1M2.002 4a1 1 0 0 0-1 1v8l2.646-2.354a.5.5 0 0 1 .63-.062l2.66 1.773 3.71-3.71a.5.5 0 0 1 .577-.094l1.777 1.947V5a1 1 0 0 0-1-1z"/>
            </svg>
        </div>
        <div class="d-flex justify-content-center">
            <div class="form-check">
                <input class="form-check-input" type="checkbox" value="jpeg" id="jpgCheck" checked>
                <label class="form-check-label" for="flexCheckDefault">
                  .jpeg
                </label>
              </div>
              <div class="form-check">
                <input class="form-check-input" type="checkbox" value="png" id="pngCheck">
                <label class="form-check-label" for="flexCheckChecked">
                  .png
                </label>
              </div>
              <div class="form-check">
                <input class="form-check-input" type="checkbox" value="svg" id="svgCheck">
                <label class="form-check-label" for="flexCheckChecked">
                  .svg
                </label>
              </div>
        </div>
        <button id="downloadCombined" style="margin: 20px;" type="button" class="btn btn-primary">Zapisz</button>

        <canvas id="combinedCanvas" style="display:none;"></canvas> <!-- Hidden Canvas for combining images -->
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/1.6.8/axios.min.js"></script>

    <!-- JIMP - IMAGE MANIPULATIO LIBRARY -->
    <script src="https://cdn.jsdelivr.net/npm/jimp@1.6.0/dist/commonjs/index.min.js"></script> 

    <!-- <script src="{% static 'js/curveAdjustment.js' %}"></script>
    <script src="{% static 'js/curvePanel.js' %}"></script> -->

    <script src="https://cdn.jsdelivr.net/npm/@imgly/background-removal@1.5.5/esm"></script> 

    <!-- IMAGE COMPRESION -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pica/9.0.1/pica.min.js"></script>


    <script>
        const csrfToken = document.getElementById('csrf-token').getAttribute('data-token');
        const form = document.getElementById('imageForm');
        const inputFile = document.getElementById('image');
        const threshold_ = document.getElementById('threshold');
        const triggerFileInput = document.getElementById('triggerFileInput');
        const spinner = document.getElementById('spinner');
        const thumbnailArea = document.getElementById('thumbnailArea');
        const downloadCombined = document.getElementById('downloadCombined');
        const combinedCanvas = document.getElementById('combinedCanvas');
        const imageNavCont = document.getElementById('navProImg');

        const brightnessSlider = document.getElementById('brightnessSlider');
        const redSlider = document.getElementById('redSlider');
        const greenSlider = document.getElementById('greenSlider');
        const blueSlider = document.getElementById('blueSlider');
        const contrastSlider = document.getElementById('contrastSlider');

        const curveIcon = document.getElementById('curve');
        let draggedImage = null;
        let isActiveImage = false;
        let imageName = null;
        let imagURL = null
        let activeImage = null;
        let zIndexCounter = 1;
        let nameCounter = 0;

        let cashedBrightnessSlider = 1;
        let cashedRedSlider = 1;
        let cashedGreenSlider = 1;
        let cashedBlueSlider = 1;
        let cashedContrastSlider = 1;
        let addCash = false;
        let copyCash = false;
        let resizableCash = false;
        let resizableCashWidth = 300;
        let resizableCashHeight = 300;

        let originalImageData = null;  // Store the original image data

        // Get the existing canvas and image element
        const curvedCanvas = document.getElementById('curvedCanvas');
        const ctx = curvedCanvas.getContext('2d');
        const imgElement = document.getElementsByClassName('imgElement_' + activeImage)[0];


        // // Initialize popovers using JavaScript
        // const makeCopyEl = document.getElementById('makeCopy');
        // const makeCopyIcon = document.getElementById('makeCopyIcon');
        // const addCopyEl = document.getElementById('addCopy');
        // const addCopyIcon = document.getElementById('addCopyIcon');

        // // Show popover on hover
        // makeCopyIcon.addEventListener('mouseenter', function() {
        //     makeCopyEl.style.display = 'block';
        // });
        // addCopyIcon.addEventListener('mouseenter', function() {
        //     addCopyEl.style.display = 'block';
        // });

        // // Hide popover when the mouse leaves the button or popover
        // makeCopyIcon.addEventListener('mouseleave', function() {
        //     makeCopyEl.style.display = 'none';
        // });
        // addCopyIcon.addEventListener('mouseleave', function() {
        //     addCopyEl.style.display = 'none';
        // });

        function isDraw_() {

            const resizable = document.getElementById('resizable' + activeImage);
            let x = null;
            let y = null;
            let points = [];
            let isDrawing = false;
            let lineSVG = document.createElement('svg');
            let line = document.createElement('line');
            line.setAttribute('x1', '0');
            line.setAttribute('y1', '0');
            line.setAttribute('x2', '100px'); // For viewport width
            line.setAttribute('y2', '100px'); // For viewport height
            line.style.stroke = 'red';
            line.style.strokeWidth = '2px';
            lineSVG.appendChild(line);
            lineSVG.style.zIndex = resizable.style.zIndex + 1;
            resizable.appendChild(lineSVG);

            

            // Funkcja rysowania linii między punktami
            resizable.addEventListener('click', function(e) {
                const rect = curvedCanvas.getBoundingClientRect();
                x = e.clientX - rect.left;
                y = e.clientY - rect.top;

                if (!isDrawing) {
                    isDrawing = true;
                    points.push({x: x, y: y});
                } else {
                    points.push({x: x, y: y});
                    drawLine(points[points.length - 2], points[points.length - 1]);
                }

                // console.log('points', points);
            });

            // Funkcja rysowania linii
            function drawLine(point1, point2) {

                console.log('point1', point1);
                console.log('point2', point2);
                line.setAttribute('x1', point1.x);
                line.setAttribute('y1', point2.y);
                line.setAttribute('x2', point2.x); // For viewport width
                line.setAttribute('y2', point2.y);
                // ctx.beginPath();
                // ctx.moveTo(point1.x, point1.y);
                // ctx.lineTo(point2.x, point2.y);
                // ctx.stroke();
            }

            // Funkcja zamknięcia obszaru
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && points.length > 2) {
                    closeArea();
                }
            });

            function closeArea() {
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.closePath();
                ctx.stroke();
            }

            // Usuwanie zaznaczonego obszaru
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Delete' && points.length > 2) {
                    deleteSelectedArea();
                }
            });

            function deleteSelectedArea() {
                ctx.save();
                ctx.globalCompositeOperation = 'destination-out';  // Ustaw tryb usuwania
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.restore();

                // Resetujemy zaznaczone punkty
                points = [];
                isDrawing = false;
            }
        }


        function isDraw__() {
            const resizable = document.getElementById('resizable' + activeImage);
            const imgElement = document.getElementsByClassName('imgElement_' + activeImage)[0];
            let points = [];
            let isDrawing = false;

            let canvas = document.getElementById('selectionCanvas');
            canvas.style.display = 'block';
            canvas.style.background = 'transparent';
            canvas.style.zIndex = resizable.style.zIndex + 1;
            let ctx = canvas.getContext('2d');

            // Event listener for clicks to draw lines between points
            canvas.addEventListener('click', function (e) {
                const rect = resizable.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                if (!isDrawing) {
                    isDrawing = true;
                    points.push({ x: x, y: y });
                } else {
                    points.push({ x: x, y: y });
                    drawLine(points[points.length - 2], points[points.length - 1]);

                    if (points.length >= 3 && isShapeClosed(points)) {
                        isDrawing = false;
                    }
                }
            });

            // Function to draw a line between two points
            function drawLine(point1, point2) {
                ctx.beginPath();
                ctx.moveTo(point1.x, point1.y);
                ctx.lineTo(point2.x, point2.y);
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Function to check if the shape is closed
            function isShapeClosed(points) {
                const dx = Math.abs(points[0].x - points[points.length - 1].x);
                const dy = Math.abs(points[0].y - points[points.length - 1].y);
                return dx < 5 && dy < 5; // Tolerance for closure
            }

            // Listen for the 'Delete' key press to clear the area inside the drawn shape
            document.addEventListener('keydown', function (e) {
                if (e.key === 'Delete' && points.length > 2) {
                    clearImageDataInside(points);
                }
            });

            // Function to clear the image data inside the drawn shape
            function clearImageDataInside(points) {
                const rect = resizable.getBoundingClientRect();
                const img = new Image();
                img.src = imgElement.src;
                // console.log('img', img)

                let originData = null;

                console.log('img.natural demensions', img.naturalWidth, img.naturalHeight)
                console.log('points', points)
                img.onload = function () {
                    canvas.width = img.naturalWidth; // Set canvas size to match the image
                    canvas.height = img.naturalHeight;
                    ctx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight);
                    originData = ctx.getImageData(0, 0, canvas.width, canvas.height); // Get the image data after drawing
                    console.log('originData', originData.data);
                    deleteData();
                };

                function deleteData() {
                    const imageData = new ImageData(
                    new Uint8ClampedArray(originData.data),
                        originData.width,
                        originData.height
                    );

                    const data = imageData.data;
                    console.log('imageData.data', data)

                    const xValues = points.map(p => p.x);
                    const yValues = points.map(p => p.y);
                    console.log('xValues', xValues);
                    console.log('yValues', yValues);
                    // The points is inside 500 x 500 px but original size of the image is too much bigger
                    // So I need to pre calculate points or image size to be good;
                    const minX = Math.min(...xValues);
                    const minY = Math.min(...yValues);
                    const maxX = Math.max(...xValues);
                    const maxY = Math.max(...yValues);

                    // const length = data.length;
                    // start = Math.max(0, 3000000); // Ensure start is not negative
                    // end = Math.min(length - 1, 3999999); // Ensure end is within bounds
                    // for (let i = start; i <= end; i++) {
                    //     data[i] = 0;
                    // }

                    // console.log('imageData.after', data)

                    // Loop over the image pixels within the bounding box
                    for (let y = minY; y <= maxY; y++) {
                        for (let x = minX; x <= maxX; x++) {
                            // Check if the point is inside the drawn polygon
                            if (isPointInPolygon(points, x, y)) {
                                // const index = (y * canvas.width + x) * 4;
                                const index = (y * img.naturalWidth + x) * 4;
                                console.log('index', Math.round(index))
                                console.log('data[index + 3]', data[Math.round(index) + 3])
                                data[Math.round(index) + 3] = 0; // Alpha channel
                                // Set the alpha channel to 0 (transparent)
                                // data[index + 3] = 0; // Alpha channel
                            }
                        }
                    }

                    imgElement.remove();
                    ctx.putImageData(imageData, 0, 0); // Put the modified image data back on the canvas

                }
            }

            // Function to check if a point is inside a polygon
            function isPointInPolygon(points, x, y) {
                let isInside = false;
                for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
                    const xi = points[i].x, yi = points[i].y;
                    const xj = points[j].x, yj = points[j].y;

                    const intersect = ((yi > y) !== (yj > y)) &&
                        (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                    if (intersect) isInside = !isInside;
                }
                return isInside;
            }
        }




        function duplicateImg() {

            const imgElement = document.getElementsByClassName('imgElement_' + activeImage)[0];
            resizableCash = true;
            resizableCashWidth = imgElement.offsetWidth;
            resizableCashHeight = imgElement.offsetHeight;
            let newImgName = null;
            newImgName = `${activeImage}_${nameCounter}`;
            nameCounter++;

            workWithImage (newImgName, imgElement.src)
        }

        function horizontalTurn() {
            const imgElement = document.getElementsByClassName('imgElement_' + activeImage)[0];
            
            // Toggle the mirror effect
            if (imgElement.style.transform === 'scaleX(-1)') {
                imgElement.style.transform = ''; // Reset to normal
            } else {
                imgElement.style.transform = 'scaleX(-1)'; // Mirror horizontally
            }
        }

        function verticalFlip() {
            const imgElement = document.getElementsByClassName('imgElement_' + activeImage)[0];

            // Toggle vertical mirror effect
            if (imgElement.style.transform === 'scaleY(-1)') {
                imgElement.style.transform = ''; // Reset to normal
            } else {
                imgElement.style.transform = 'scaleY(-1)'; // Mirror vertically
            }
        }


        function addGrad() {
            const imgElement = document.getElementsByClassName('imgElement_' + activeImage)[0];
            imgElement.style.maskImage = 'linear-gradient(to top, rgb(0, 0, 0) 0%, rgba(0, 0, 0, 0) 40%)';
        }


        function deleteImg() {
            const fullImgCont = document.getElementById('resizable' + activeImage);
            const imgElement = document.getElementsByClassName('imgElement_' + activeImage)[0];
            console.log('fullImgCont and imgElement', fullImgCont, imgElement)
            console.log('imageName and activeImage', imageName, activeImage)
            imgElement.remove();
            fullImgCont.remove();
        }


        function justEncodeImageToBase64(imagePath) {
            return fetch(imagePath)
                .then(response => response.blob())       // Fetch and convert to blob
                .then(blob => {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result);  // Base64 string
                        reader.onerror = reject;
                        reader.readAsDataURL(blob);  // Start the conversion
                    });
                })
                .catch(error => {
                    console.error('Error encoding image to base64:', error);
                    throw error;
                });
        }


        // async function addGradientToImage_() {
        //     const imgElement = document.getElementsByClassName('imgElement_' + activeImage)[0];
        //     const imageSrc = imgElement.src;

        //     let mirrorElementName = null;
        //     newImgMirrorName = `${activeImage}_${nameCounter}`;
        //     nameCounter++;

        //     // Fetch the image as a Blob
        //     const response = await fetch(imageSrc);
        //     const blob = await response.blob();

        //     const formData = new FormData();
        //     formData.append('image', blob, 'image.png'); // Append the image blob with a filename
        //     console.log('formData front', formData)

        //     // Send the image to your backend API
        //     try {
        //         const result = await axios.post("{% url 'mirror_image' %}", formData, {
        //             headers: {
        //                 'X-CSRFToken': csrfToken,
        //                 'Content-Type': 'multipart/form-data',
        //             }
        //         });

        //         console.log('formData response', response)
        //         // imageName = response.data.imgName;
        //         imagURL = response.url //data.image_data_url
        //         workWithImage(mirrorElementName, imagURL)

        //     } catch (error) {
        //         console.error('Error sending image to server:', error);
        //     }
        // }




        // function addGradientToImage() {

        //     const imgElement = document.getElementsByClassName('imgElement_' + activeImage)[0];
        //     let height_ = imgElement.offsetHeight; //imageObj2.naturalHeight/8
        //     let width_ = imgElement.offsetWidth; //imageObj2.naturalWidth/8
        //     console.log('size', height_, width_)
        //     // console.log('addGradientToImage - imgElement', imgElement)

        //     let mirrorElementName = null;
        //     newImgMirrorName = `${activeImage}_${nameCounter}`;
        //     nameCounter++;
        //     // mirrorElement.style.maskImage = 'linear-gradient(to top, rgb(0, 0, 0) 0%, rgba(0, 0, 0, 0) 40%)';


        //     var c = document.getElementById("curvedCanvas");
        //     var ctx = c.getContext("2d");
        //     var imageObj1 = new Image();
        //     var imageObj2 = new Image();
        //     imageObj1.src = imgElement.src
        //     imageObj1.onload = function() {
        //         ctx.drawImage(imageObj1, 0, 0, width_, height_);
        //         imageObj2.src = imgElement.src;
        //         imageObj2.onload = function() {

        //             // ctx.drawImage(imageObj2, 0, 0, imageObj2.naturalWidth/10, imageObj2.naturalHeight/10);
        //             // var img = c.toDataURL("image/png");
        //             // workWithImage(newImgMirrorName, img)

        //             // let height_ = imageObj2.offsetHeight; //imageObj2.naturalHeight/8
        //             // let width_ = imageObj2.offsetWidth; //imageObj2.naturalWidth/8

        //             // Save the current context                   
        //             // ctx.save();
        //             // Flip the canvas horizontally and vertically //leftPosition + imageObj2.naturalWidth/10, topPosition + imageObj2.naturalHeight/10
        //             ctx.translate(0, height_ + width_); // Translate to the bottom right of the image
        //             ctx.scale(1, -1); // flip by x, y
        //             ctx.filter = "opacity(0.20)";

        //             // Draw the mirrored image (the image is now flipped)
        //             ctx.drawImage(imageObj2, 0, 0, width_, height_);

        //             // Restore the context to original state
        //             // ctx.restore();

        //             var img = c.toDataURL("image/png");
        //             workWithImage(newImgMirrorName, img); 
        //             addGrad();
        //             // addGrad(newImgMirrorName, img, height_, width_); 
        //         }

        //     };
        //     imgElement.remove();

        // }

        

        function showShadowContainer() {
                const processImg = document.getElementById('shadowContainer');
                if ( processImg.style.display === 'none' ) {
                    processImg.style.display = 'block';
                } else {
                    processImg.style.display = 'none';
                }
            }


        function addShadow() {

            const imagePath = '/static/icons/shadow_shape.png';
            let newImgName = null;
            newImgName = `shadow_shape_${nameCounter}`;
            nameCounter++;

            const imageData64 = encodeImageToBase64(newImgName, imagePath);

        }

        function encodeImageToBase64(newImgName, imagePath) {
            fetch(imagePath)
                .then(response => response.blob())  // Get the image as a blob
                .then(blob => {
                    const reader = new FileReader();
                    reader.onloadend = function () {
                        const base64String = reader.result; // Base64 encoded string
                        console.log(base64String);
                        // Now you can use the base64String in your image src or anywhere else
                        // e.g., pass it to your function
                        workWithImage(newImgName, base64String);
                    };
                    reader.readAsDataURL(blob);  // Convert blob to base64
                })
                .catch(error => console.error('Error encoding image to base64:', error));
        }



            function showProcContainer() {
                const processImg = document.getElementById('procContainer');
                if ( processImg.style.display === 'none' ) {
                    processImg.style.display = 'block';
                } else {
                    processImg.style.display = 'none';
                }
            }

            // Debounce function to limit the frequency of slider adjustments
            function debounce(func, wait = 100) {
                let timeout;
                return function (...args) {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(this, args), wait);
                };
            }

            // Add event listeners for the sliders with debounce
            document.getElementById('brightnessSlider').addEventListener('input', debounce(applyBrightness));
            document.getElementById('redSlider').addEventListener('input', debounce(applyBrightness));
            document.getElementById('greenSlider').addEventListener('input', debounce(applyBrightness));
            document.getElementById('blueSlider').addEventListener('input', debounce(applyBrightness));
            document.getElementById('contrastSlider').addEventListener('input', debounce(applyBrightness));

            // Apply curve adjustment based on the brightness and RGB values
            function applyBrightness() {

                console.log('addCash', addCash)

                let brightnessSlider = null;
                let redSlider = null;
                let greenSlider = null;
                let blueSlider = null;
                let contrastSlider = 0;

                if ( addCash ) {
                    console.log('addCash true')
                    brightnessSlider = cashedBrightnessSlider;
                    redSlider = cashedRedSlider;
                    greenSlider = cashedGreenSlider;
                    blueSlider = cashedBlueSlider;
                    contrastSlider = cashedContrastSlider;
                    addCash = false;
                } else {
                    // Get slider values
                    brightnessSlider = document.getElementById('brightnessSlider').value;
                    redSlider = document.getElementById('redSlider').value;
                    greenSlider = document.getElementById('greenSlider').value;
                    blueSlider = document.getElementById('blueSlider').value;
                    contrastSlider = document.getElementById('contrastSlider').value;

                }

                console.log('brightnessSlider:', brightnessSlider);
                console.log('redSlider:', redSlider);
                console.log('greenSlider:', greenSlider);
                console.log('blueSlider:', blueSlider);
                console.log('contrastSlider:', contrastSlider);

                // Get the existing canvas and image element
                const curvedCanvas = document.getElementById('curvedCanvas');
                const ctx = curvedCanvas.getContext('2d');
                const imgElement = document.getElementsByClassName('imgElement_' + activeImage)[0];

                if (!imgElement) {
                    console.error('Image element not found');
                    return;
                }

                // Set canvas dimensions once (on initial load)
                if (!originalImageData) {
                    curvedCanvas.width = imgElement.naturalWidth;
                    curvedCanvas.height = imgElement.naturalHeight;

                    // Draw the image onto the canvas and store the original image data
                    const img = new Image();
                    img.src = imgElement.src;

                    img.onload = function () {
                        console.log('contrastSlider', contrastSlider)
                        ctx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight);

                        originalImageData = ctx.getImageData(0, 0, curvedCanvas.width, curvedCanvas.height); // Save original data
                        applyChanges();
                    };

                    img.onerror = function () {
                        console.error('Error loading the image for curving.');
                    };
                } else {
                    // if ( blurSlider !== 0 ) {
                    //         console.log('blurSlider !== 0 else', blurSlider)
                    //         ctx.filter = `blur(${parseFloat(blurSlider)}px)`;
                    //     }
                    applyChanges();  // Apply changes on subsequent slider movements
                }


                function applyChanges() {
                    // Get the original image data for manipulation (clone it each time to reset to original)
                    const imageData = new ImageData(
                        new Uint8ClampedArray(originalImageData.data),
                        originalImageData.width,
                        originalImageData.height
                    );
                    const data = imageData.data; // Array of pixel data [r,g,b,a, r,g,b,a, ...]

                    // Apply the curve adjustment logic for brightness, RGB channels, and contrast
                    const brightnessFactor = parseFloat(brightnessSlider);
                    const redFactor = parseFloat(redSlider);
                    const greenFactor = parseFloat(greenSlider);
                    const blueFactor = parseFloat(blueSlider);
                    const contrastValue = parseFloat(contrastSlider); // Assuming you have a slider for contrast

                    // Calculate contrast factor
                    const contrastFactor = (259 * (contrastValue + 255)) / (255 * (259 - contrastValue));

                    for (let i = 0; i < data.length; i += 4) {
                        // Apply RGB and brightness adjustments first
                        data[i] = Math.min(255, data[i] * redFactor * brightnessFactor);     // Red channel
                        data[i + 1] = Math.min(255, data[i + 1] * greenFactor * brightnessFactor); // Green channel
                        data[i + 2] = Math.min(255, data[i + 2] * blueFactor * brightnessFactor);  // Blue channel

                        // Apply contrast adjustment for each channel (R, G, B)
                        data[i] = clamp(((data[i] - 128) * contrastFactor) + 128);   // Red channel contrast
                        data[i + 1] = clamp(((data[i + 1] - 128) * contrastFactor) + 128); // Green channel contrast
                        data[i + 2] = clamp(((data[i + 2] - 128) * contrastFactor) + 128); // Blue channel contrast
                    }

                    // Put the modified image data back onto the canvas
                    ctx.putImageData(imageData, 0, 0);

                    // Replace the original image's src with the adjusted image from the canvas
                    imgElement.setAttribute('brightness', parseFloat(brightnessSlider));
                    imgElement.setAttribute('red', parseFloat(redSlider));
                    imgElement.setAttribute('green', parseFloat(greenSlider));
                    imgElement.setAttribute('blue', parseFloat(blueSlider));
                    imgElement.setAttribute('contrast', parseFloat(contrastSlider));

                    // Replace the original image's src with the adjusted image from the canvas
                    imgElement.src = curvedCanvas.toDataURL(); // Get the base64 image data
                }

                // Helper function to clamp values between 0 and 255
                function clamp(value) {
                    return Math.max(0, Math.min(255, value));
                }


            }


            // Function to apply brightness and RGB adjustments to original image data
            function makeCopy() {
                // Get slider values
                const brightnessSlider = document.getElementById('brightnessSlider').value;
                const redSlider = document.getElementById('redSlider').value;
                const greenSlider = document.getElementById('greenSlider').value;
                const blueSlider = document.getElementById('blueSlider').value;
                const contrastSlider = document.getElementById('contrastSlider').value;

                cashedBrightnessSlider = brightnessSlider;
                cashedRedSlider = redSlider;
                cashedGreenSlider = greenSlider;
                cashedBlueSlider = blueSlider;
                cashedContrastSlider = contrastSlider;

                copyCash = true;
            }

            function addCopy() {
                addCash = true;
                applyBrightness()
            }


            // Function to apply brightness and RGB adjustments to original image data
            function setValues(imgIndex) {

                const elem = document.getElementsByClassName('imgElement_' + imgIndex)[0];

                brightnessSlider.value = elem.getAttribute('brightness');
                redSlider.value = elem.getAttribute('red');
                greenSlider.value = elem.getAttribute('green');
                blueSlider.value = elem.getAttribute('blue');
                contrastSlider.value = elem.getAttribute('contrast');

            }





        // Function to curve the image
        function transformationffect() {
            // Get the existing canvas element
            const curvedCanvas = document.getElementById('curvedCanvas');
            const ctx = curvedCanvas.getContext('2d');

            // Get the image element by class name (or id)
            const imgElement = document.getElementsByClassName('imgElement_IMG_5615.JPG')[0]; // Get the first element

            if (!imgElement) {
                console.error('Image element not found');
                return;
            }

            console.log('applyCurvedEffect - imgElement', imgElement);

            // Set canvas dimensions to match the image
            curvedCanvas.width = imgElement.width;
            curvedCanvas.height = imgElement.height;

            // Create a new image object and set its source to the existing image's source
            const img = new Image();
            img.src = imgElement.src;

            // Wait until the image has loaded before drawing
            img.onload = function () {
                // Draw the image on the canvas first
                ctx.drawImage(img, 0, 0, imgElement.width, imgElement.height);

                // Apply the curve processing logic here
                const curveIntensity = 0.05; // Adjust for curve intensity
                const curveOffset = 20; // Adjust for curve depth

                const width = imgElement.width;
                const height = imgElement.height;

                // Apply curving effect row by row
                for (let y = 0; y < height; y++) {
                    const offset = Math.sin(y * curveIntensity) * curveOffset;
                    ctx.drawImage(img, 0, y, width, 1, offset, y, width, 1); // Draw each row with an offset
                }

                // Now replace the original image's src with the curved image from the canvas
                imgElement.src = curvedCanvas.toDataURL(); // Get the base64 image data
                console.log('Curved image applied successfully');
            };

            // If the image fails to load
            img.onerror = function () {
                console.error('Error loading the image for curving.');
            };
        }




        const resultCont = document.getElementById('result');
        resultCont.style.display = 'flex';

        // GET TRASHOLD VALUE
        window.onload = function() {
            // Set the initial value to 0 when the page loads
            const rangeInput = document.getElementById('threshold');
            rangeInput.value = 0; // Set the default value

            // Display the initial value
            document.getElementById('rangeValueDisplay').innerText = rangeInput.value;
        };
        function getRangeValue() {

            // Get the value of the range input
            const rangeValue = threshold_.value;

            // Display the value in a <p> element or use it in your logic
            document.getElementById('rangeValueDisplay').innerText = rangeValue;
        }



        triggerFileInput.addEventListener('click', () => {
            inputFile.click(); // Trigger file input click
        });

        inputFile.addEventListener('change', () => {
            if (inputFile.files.length > 0) {
                spinner.style.display = 'block';
                const formData = new FormData(form);
                // const threshold = rangeValue;
                console.log('formData', formData)
                formData.append('threshold', threshold_.value);

                axios.post("{% url 'remove_bg' %}", formData, {
                    headers: {
                        'X-CSRFToken': csrfToken,
                        'Content-Type': 'multipart/form-data',
                    }
                })
                .then(response => {
                    spinner.style.display = 'none';
                    if (response.data.success) {

                        imageName = response.data.imgName;
                        imagURL = response.data.image_data_url

                        document.getElementById('brightnessSlider').value = 1;
                        document.getElementById('redSlider').value = 1;
                        document.getElementById('greenSlider').value = 1;
                        document.getElementById('blueSlider').value = 1;
                        document.getElementById('contrastSlider').value = 0;
                        originalImageData = null;

                        workWithImage (imageName, imagURL);
                        
                    } else {
                        alert('Failed to process the image.');
                    }
                })
                .catch(error => {
                    spinner.style.display = 'none';
                    console.error('Error:', error);
                    alert('An error occurred. Please try again.');
                });
            
            }
        });


        function workWithImage (imageName, imagURL) {

                        originalImageData = null; // delete cashed image for brightness and color correction
                        activeImage = imageName
                        // logic to download result in original size
                        const outputImageCont = document.createElement('div');
                        outputImageCont.id = `outputImageCont${imageName}`;
                        outputImageCont.style.display = 'flex';
                        outputImageCont.style.alignItems = 'center';
                        outputImageCont.style.justifyContent = 'space-between';
                        const outputImage = document.createElement('img'); 
                        outputImage.id = `outputImage${imageName}`;
                        outputImage.src = imagURL;
                        outputImage.style.display = 'block';
                        outputImage.style.width = '150px';

                        // Make the image draggable
                        outputImage.draggable = true;
                        outputImage.ondragstart = function(event) {
                            event.dataTransfer.setData('text/plain', event.target.id);
                            nameCounter++;
                            const dragImg = document.getElementById(`outputImage${imageName}`);
                            let newImgName = null;
                            newImgName = `${activeImage}_${nameCounter}`;
                            nameCounter++;

                            workWithImage (newImgName, dragImg.src)
                        };

                        // thumbnailArea.ondrop = function(event) {
                        //     event.preventDefault();
                        //     nameCounter++;
                        //     const dragImg = document.getElementById(`outputImage${imageName}`);
                        //     let newImgName = null;
                        //     newImgName = `${activeImage}_${nameCounter}`;
                        //     nameCounter++;

                        //     workWithImage (newImgName, dragImg.src)
                        // };


                        outputImage.onclick = function () {
                            // Get all images within the same container and remove the 'activeImage' class
                            const allImages = resultCont.querySelectorAll('img');
                            allImages.forEach(img => img.classList.remove('activeImage'));

                            // Add the 'activeImage' class only to the clicked image
                            outputImage.classList.add('activeImage');
                        }

                        const downloadLink = document.createElement('a'); //document.getElementById('downloadLink');
                        downloadLink.href = imagURL; //response.data.image_data_url;
                        downloadLink.download = "processed_image.png";
                        downloadLink.style.display = 'block';
                        const uploadImg = document.createElement('img');
                        uploadImg.src = "{% static 'icons/upload.svg' %}";
                        downloadLink.appendChild(uploadImg);

                        const addImg = document.createElement('img');
                        addImg.src = "{% static 'icons/close.svg' %}";
                        addImg.style.width = '16px';
                        addImg.onclick = function () {
                            const fullImgCont = document.getElementById('resizable' + imageName);
                            if ( fullImgCont ) {
                                fullImgCont.remove();
                            }
                            outputImage.remove();
                            if ( outputImageCont ) {
                                outputImageCont.remove();
                            }
                        }

                        outputImageCont.appendChild(downloadLink);
                        outputImageCont.appendChild(addImg);

                        resultCont.appendChild(outputImage);
                        resultCont.appendChild(outputImageCont);

                        // let zIndexCounter = 1;

                        // logic for create a thumbnail
                        const resizableContainer = document.createElement('div');
                        resizableContainer.classList.add('resizable');
                        resizableContainer.id = 'resizable' + imageName;

                        if ( resizableCash ) {
                            resizableContainer.style.width = `${resizableCashWidth}px`;  // Initial width
                            resizableContainer.style.height = `${resizableCashHeight}px`; // Initial height
                        } else {
                            resizableContainer.style.width = '300px';  //`${300 * aspectRatio}px`; // Initial width
                            resizableContainer.style.height = '300px';//`${300 / aspectRatio}px`; // Initial height
                        }
                        
                        resizableContainer.style.zIndex = zIndexCounter++;

                        const imgElement = document.createElement('img');
                        imgElement.src = imagURL; //response.data.image_data_url;
                        imgElement.setAttribute('data-index', imageName);
                        imgElement.classList.add('imgElement_' + imageName);

                        imgElement.setAttribute('brightness', 1);
                        imgElement.setAttribute('red', 1);
                        imgElement.setAttribute('green', 1);
                        imgElement.setAttribute('blue', 1);
                        imgElement.setAttribute('contrast', 0);

                        // Calculate aspect ratio and fit image within the container's size
                        const originalWidth = imgElement.naturalWidth;
                        const originalHeight = imgElement.naturalHeight;
                        const aspectRatio = originalWidth / originalHeight;
                        console.log('originalWidth x originalHeight', originalWidth, originalHeight)
                        console.log('aspectRatio', aspectRatio)
                        console.log('300 / aspectRatio', 300 / aspectRatio)
                        console.log('imgElement dimensions', imgElement.offsetWidth, imgElement.offsetHeight)

                        imgElement.onclick = function () {

                            console.log('isActiveImage', isActiveImage)

                            const imgIndex = this.getAttribute('data-index');
                            console.log('onclick imgIndex', imgIndex);

                            activeImage = imgIndex

                            if ( isActiveImage === true ) {
                                setInactiveImg(imgIndex);
                            } else {
                                setActiveImg(imgIndex);
                            }
                            
                            // resizeImage(imgIndex);  // Pass the index to the resizeImage function
                        }
                        resizableContainer.appendChild(imgElement);

                        resizableCash = false;

                        // // Add resize handles for all corners
                        const handles = ['tl', 'tr', 'bl', 'br'];
                        handles.forEach(handle => {
                            const resizeHandle = document.createElement('div');
                            resizeHandle.setAttribute('data-index', imageName);
                            resizeHandle.classList.add('resize-handle', handle);
                            resizableContainer.appendChild(resizeHandle);
                        });

                        // SHOW MENU
                            const properCont = document.createElement('div');
                            properCont.classList.add('pr');
                            properCont.style.display = 'none';
                            const icons = ['close'];
                            let menuActive = false;

                            properCont.onclick = function() { 
                                console.log('menuActive', menuActive)

                                if ( menuActive === false) {
                                    console.log('menuActive show', menuActive)

                                    const menuContExisted = document.getElementsByClassName('menuActive' + imageName) [0];
                                    if ( menuContExisted ) {
                                        console.log('menuContExisted', menuContExisted)
                                        menuContExisted.style.display = 'flex';

                                        icons.forEach(icon => {
                                            const iconCont = document.getElementsByClassName(icon)[0]
                                            iconCont.style.display = 'block';  // Hide the menu
                                            menuActive = true;
                                        })
                                    } else {
                                        const menuCont = document.createElement('div');
                                        menuCont.classList.add('menuActive' + imageName);
                                        menuCont.style.display = 'flex';
                                        menuCont.style.flexDirection = 'column';
                                
                                        icons.forEach(icon => {
                                            const resizeHandle = document.createElement('div');
                                            resizeHandle.classList.add(icon);
                                            
                                            // Add onclick event
                                            resizeHandle.onclick = function() {
                                                deleteImg()
                                            };

                                            menuCont.appendChild(resizeHandle);
                                        });


                                        resizableContainer.appendChild(menuCont);
                                        menuActive = true;
                                    }
                                } else {
                                    
                                    console.log('menuActive none', menuActive)
                                    // const menuCont = document.getElementsByClassName('menuActive') [0]; // Get the first element with the class 'menuActive'

                                    // properCont.style.display = 'none';
                                    menuActive = false;

                                    icons.forEach(icon => {
                                        const iconCont = document.getElementsByClassName(icon)[0]
                                        iconCont.style.display = 'none';  // Hide the menu
                                        // menuActive = false;
                                    })
            
                                }
                            };

                            resizableContainer.appendChild(properCont);
                        // END SHOW MENU

                        function showMenuMini() {
                            if ( properCont.style.display === 'none' ) {
                                properCont.style.display = 'block';
                            } else {
                                properCont.style.display = 'none';
                            }
                        }


                        function setInactiveImg(imgIndex) {
                            showMenuMini();
                            originalImageData = null;
                            resizableContainer.style.border = 'none';
                            const resizeHandle = document.querySelectorAll('.resize-handle');
                            resizeHandle.forEach(handler => handler.style.display = 'none');

                            // Hide the rotation handle
                            const rotationHandle = document.getElementsByClassName('rotate-handle_' + imageName);
                            console.log('setInactiveImg - rotationHandle', rotationHandle);
                            
                            if (rotationHandle.length > 0) { // Check if there is a rotation handle
                                Array.from(rotationHandle).forEach(handler => handler.style.display = 'none');
                            }

                            isActiveImage = false;
                        }

                        function setActiveImg(imgIndex) {
                            showMenuMini();
                            originalImageData = null;
                            resizableContainer.style.border = 'block';
                            const resizeHandle = document.querySelectorAll('.resize-handle');
                            resizeHandle.forEach(handler => handler.style.display = 'block');
                            isActiveImage = true;
                            activeImage = imgIndex;

                             // Add click event listener to bring the clicked image to the front
                            resizableContainer.addEventListener('mousedown', function () {
                                // Bring this container to the front
                                resizableContainer.style.zIndex = zIndexCounter++;
                            });

                            resizeImage(imgIndex);
                            startRotate(imageName);
                            setValues(imageName);
                            // isDraw(imageName);
                        }


                        function isDraw(imageName) {

                            console.log('isDraw');

                            isDrawing = false;
                            let x = null;
                            let y = null;
                            let points = [];

                            let lineSVG = document.createElement('svg');
                            let line = document.createElement('line');
                            line.setAttribute('x1', '0');
                            line.setAttribute('y1', '0');
                            line.setAttribute('x2', '100px'); // For viewport width
                            line.setAttribute('y2', '100px'); // For viewport height
                            line.style.stroke = 'red';
                            line.style.strokeWidth = '2px';
                            lineSVG.appendChild(line);
                            resizableContainer.appendChild(lineSVG);

                            // Funkcja rysowania linii między punktami
                            resizableContainer.addEventListener('click', function(e) {
                                // let lineSVG = document.createElement('svg');
                                // let line = document.createElement('line');
                                // line.setAttribute('x1', '0');
                                // line.setAttribute('y1', '0');
                                // line.setAttribute('x2', '100px'); // For viewport width
                                // line.setAttribute('y2', '100px'); // For viewport height
                                // line.style.stroke = 'red';
                                // line.style.strokeWidth = '2px';
                                // lineSVG.appendChild(line);
                                // resizableContainer.appendChild(lineSVG);
                                x = e.clientX;
                                y = e.clientY;

                                if (!isDrawing) {
                                    isDrawing = true;
                                    points.push({x: x, y: y});
                                } else {
                                    points.push({x: x, y: y});
                                    // drawLine(points[points.length - 2], points[points.length - 1]);
                                }

                                console.log('points', points);
                            });

                            // // Funkcja rysowania linii
                            // function drawLine(point1, point2) {
                            //     ctx.beginPath();
                            //     ctx.moveTo(point1.x, point1.y);
                            //     ctx.lineTo(point2.x, point2.y);
                            //     ctx.stroke();
                            // }

                            // // Funkcja zamknięcia obszaru
                            // document.addEventListener('keydown', function(e) {
                            //     if (e.key === 'Enter' && points.length > 2) {
                            //         closeArea();
                            //     }
                            // });

                            // function closeArea() {
                            //     ctx.beginPath();
                            //     ctx.moveTo(points[0].x, points[0].y);
                            //     for (let i = 1; i < points.length; i++) {
                            //         ctx.lineTo(points[i].x, points[i].y);
                            //     }
                            //     ctx.closePath();
                            //     ctx.stroke();
                            // }

                            // // Usuwanie zaznaczonego obszaru
                            // document.addEventListener('keydown', function(e) {
                            //     if (e.key === 'Delete' && points.length > 2) {
                            //         deleteSelectedArea();
                            //     }
                            // });

                            // function deleteSelectedArea() {
                            //     ctx.save();
                            //     ctx.globalCompositeOperation = 'destination-out';  // Ustaw tryb usuwania
                            //     ctx.beginPath();
                            //     ctx.moveTo(points[0].x, points[0].y);
                            //     for (let i = 1; i < points.length; i++) {
                            //         ctx.lineTo(points[i].x, points[i].y);
                            //     }
                            //     ctx.closePath();
                            //     ctx.fill();
                            //     ctx.restore();

                            //     // Resetujemy zaznaczone punkty
                            //     points = [];
                            //     isDrawing = false;
                            // }
                        }


                        function resizeImage(imgIndex) {
                            console.log('imgIndex', imgIndex);

                            // Apply a border to the container
                            resizableContainer.style.border = '2px dashed gray';

                            // Get all resize handles
                            const resizeHandles = document.querySelectorAll('.resize-handle');

                            resizeHandles.forEach((handler, index) => {
                                // console.log('handler', handler);

                                const dataIndex = handler.getAttribute('data-index');
                                // console.log('dataIndex', dataIndex);

                                // Show the handler if the index matches, otherwise hide it
                                if (dataIndex === imgIndex) {
                                    handler.style.display = 'block';
                                } else {
                                    handler.style.display = 'none';
                                }
                            });
                        }


                        // // Function to curve the image
                        // function applyCurvingToImage() {
                        //     const canvas = document.createElement('canvas');
                        //     const ctx = canvas.getContext('2d');

                        //     // Set canvas dimensions to match image
                        //     canvas.width = imgElement.width;
                        //     canvas.height = imgElement.height;

                        //     // Apply the curve processing logic here
                        //     const curveIntensity = 0.05; // Adjust for curve intensity
                        //     const curveOffset = 20; // Adjust for curve depth

                        //     const width = imgElement.width;
                        //     const height = imgElement.height;

                        //     // Draw the image on the canvas with curving effect
                        //     const img = new Image();
                        //     img.src = imgElement.src;

                        //     img.onload = function () {
                        //         for (let y = 0; y < height; y++) {
                        //             const offset = Math.sin(y * curveIntensity) * curveOffset;
                        //             ctx.drawImage(img, 0, y, width, 1, offset, y, width, 1); // Draw each row with offset
                        //         }

                        //         // Replace the image with the canvas containing the curved image
                        //         imgElement.src = canvas.toDataURL();
                        //     };
                        // }


                        let isResizing = false;
                        let isDragging = false;
                        let isRotating = false; // New flag for rotation
                        let isDrawing = false;
                        let currentHandle = null;
                        let startX, startY, startWidth, startHeight, startLeft, startTop;
                        let startRotation = 0; // To store the initial rotation angle
                        let centerX, centerY; // Center of the element for rotation

                        // Function to rotate the element
                        function handleRotation(event) {
                            const dx = event.clientX - centerX;
                            const dy = event.clientY - centerY;
                            const angle = Math.atan2(dy, dx) * (180 / Math.PI); // Calculate angle in degrees
                            const rotationAngle = angle - startRotation; // Calculate relative angle
                            resizableContainer.style.transform = `rotate(${rotationAngle}deg)`;
                        }

                        // Function to resize the element
                        function handleResize(event, direction) {
                            const dx = event.clientX - startX;
                            const dy = event.clientY - startY;

                            if (direction.includes('r')) {
                                resizableContainer.style.width = `${startWidth + dx}px`;
                            } else if (direction.includes('l')) {
                                resizableContainer.style.width = `${startWidth - dx}px`;
                                resizableContainer.style.left = `${startLeft + dx}px`;
                            }

                            if (direction.includes('b')) {
                                resizableContainer.style.height = `${startHeight + dy}px`;
                            } else if (direction.includes('t')) {
                                resizableContainer.style.height = `${startHeight - dy}px`;
                                resizableContainer.style.top = `${startTop + dy}px`;
                            }
                        }

                        // Add resize handles
                        resizableContainer.querySelectorAll('.resize-handle').forEach(handle => {
                            handle.addEventListener('mousedown', function (event) {
                                isResizing = true;
                                currentHandle = handle.classList[1]; // e.g., 'tl', 'tr', etc.
                                startX = event.clientX;
                                startY = event.clientY;
                                startWidth = resizableContainer.offsetWidth;
                                startHeight = resizableContainer.offsetHeight;
                                startLeft = resizableContainer.offsetLeft;
                                startTop = resizableContainer.offsetTop;
                                event.preventDefault();
                            });
                        });

                        function startRotate(imageName) {
                            // Add rotation handle (for example, top-center)
                            const rotationHandle = document.createElement('div');
                            rotationHandle.classList.add('rotate-handle_' + imageName);
                            rotationHandle.style.display = 'block';
                            rotationHandle.style.position = 'absolute';
                            rotationHandle.style.top = '-20px'; // Place it above the container
                            rotationHandle.style.left = '-10px';
                            rotationHandle.style.transform = 'translateX(-50%)';
                            rotationHandle.style.cursor = 'grab';
                            rotationHandle.style.backgroundImage = 'url(/static/icons/rotate_in.svg)';
                            rotationHandle.style.width = '15px';
                            rotationHandle.style.height = '15px';
                            resizableContainer.appendChild(rotationHandle);

                            // Enable rotation on mouse down
                            rotationHandle.addEventListener('mousedown', function (event) {
                                isRotating = true;
                                const rect = resizableContainer.getBoundingClientRect();
                                centerX = rect.left + rect.width / 2; // Find the center of the container
                                centerY = rect.top + rect.height / 2;
                                startX = event.clientX;
                                startY = event.clientY;
                                startRotation = Math.atan2(startY - centerY, startX - centerX) * (180 / Math.PI);
                                event.preventDefault();
                            });
                        }

                        // Enable dragging for the resizable container
                        resizableContainer.addEventListener('mousedown', function (event) {
                            if (!isResizing && !isRotating) {
                                isDragging = true;
                                startX = event.clientX - resizableContainer.offsetLeft;
                                startY = event.clientY - resizableContainer.offsetTop;
                            }
                        });

                        document.addEventListener('mousemove', function (event) {
                            if (isResizing) {
                                handleResize(event, currentHandle);
                            } else if (isDragging) {
                                resizableContainer.style.left = `${event.clientX - startX}px`;
                                resizableContainer.style.top = `${event.clientY - startY}px`;
                            } else if (isRotating) {
                                handleRotation(event);
                            } 
                        });

                        document.addEventListener('mouseup', function () {
                            isResizing = false;
                            isDragging = false;
                            isRotating = false;
                        });

                        // function draw(event) {
                        //     isDrawing = true;
                        //     startX = event.clientX;
                        //     startY = event.clientY;
                        //     var canvas = document.getElementById("curvedCanvas");
                        //     var ctx = canvas.getContext("2d");
                        //     ctx.clearRect(0, 0, canvas.width, canvas.height);
                        //     ctx.strokeStyle = 'red';
                        //     ctx.lineWidth = 2;
                        //     ctx.strokeRect(startX, startY, endX - startX, endY - startY);
                        // }


                        thumbnailArea.appendChild(resizableContainer);
                        // isActiveImage = false;
        }
    

        thumbnailArea.addEventListener('dragover', function (event) {
            event.preventDefault();
        });


        const checkboxes = document.querySelectorAll('.form-check-input');

        checkboxes.forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                if (checkbox.checked) {
                    checkboxes.forEach(other => {
                        if (other !== checkbox) {
                            other.checked = false;
                        }
                    });
                }
            });
        });


        // Function to combine images inside the thumbnailArea and download the result
        downloadCombined.addEventListener('click', function () {

            cashedBrightnessSlider = 1;
            cashedRedSlider = 1;
            cashedGreenSlider = 1;
            cashedBlueSlider = 1;
            copyCash = false;
            addCash = false;
            originalImageData = null;

            // const resizableContainers = thumbnailArea.querySelectorAll('.resizable');
            const resizableContainers = Array.from(thumbnailArea.querySelectorAll('.resizable')).slice(1); // because of canvas container for selection inside of thumbnailArea

            if (resizableContainers.length === 0) {
                alert("No images to combine!");
                return;
            }

            // Set the canvas dimensions
            const canvasWidth = 2560;
            const canvasHeight = 2560;
            combinedCanvas.width = canvasWidth;
            combinedCanvas.height = canvasHeight;

            let format = null

            checkboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    format = checkbox.value
                    // selectedFormats.push(checkbox.value);
                }
            })

            const ctx = combinedCanvas.getContext('2d');
            ctx.clearRect(0, 0, canvasWidth, canvasHeight); // Clear canvas
            if ( format === 'jpeg' ) {
                ctx.fillStyle = "rgb(255, 255, 255)"; 
            } 
            else {
                ctx.fillStyle = "rgba(0, 0, 0, 0)"; 
            }
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            let imagesLoaded = 0;


            function checkAllImagesLoaded() {
                if (imagesLoaded === resizableContainers.length) {
                    combinedCanvas.toBlob(function (blob) {
                    const img = new Image();
                    img.src = URL.createObjectURL(blob);
                    img.onload = function() {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        
                        // Set canvas to desired dimensions
                        canvas.width = 2560;
                        canvas.height = 2560;
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                        let quality = 1.0;
                        let outputBlob;



                        do {
                        const dataUrl = canvas.toDataURL(`image/${format}`, quality);
                        outputBlob = dataURLToBlob(dataUrl);
                        quality -= 0.1;
                        } while (outputBlob.size > 500 * 1024 && quality > 0.1);

                        const downloadLink = document.createElement('a');
                        downloadLink.href = URL.createObjectURL(outputBlob);
                        downloadLink.download = `result.${format}`;
                        downloadLink.click();
                    };
                    }, `image/${format}`);
                }
            }

                function dataURLToBlob(dataURL) {
                const byteString = atob(dataURL.split(',')[1]);
                const mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];
                const ab = new ArrayBuffer(byteString.length);
                const ia = new Uint8Array(ab);
                for (let i = 0; i < byteString.length; i++) {
                    ia[i] = byteString.charCodeAt(i);
                }
                return new Blob([ab], { type: mimeString });
                }




            // Draw each image on the canvas in the right size and position
            console.log('resizableContainers', resizableContainers)
            resizableContainers.forEach(container => {
                const img = container.querySelector('img');
                console.log('save loop container', container)
                // Centering uploaded image event without moving it
                const defaultLeft = (container.parentElement.offsetWidth - container.offsetWidth) / 2;
                const defaultTop = (container.parentElement.offsetHeight - container.offsetHeight) / 2;
                const left = parseInt(container.style.left) || defaultLeft;
                const top = parseInt(container.style.top) || defaultTop;


                // Create a new image object to ensure it's loaded properly
                const imgElement = new Image();
                imgElement.src = img.src;

                imgElement.onload = function () {

                    const containerWidth = container.offsetWidth; // Width of the container
                    const containerHeight = container.offsetHeight;

                    // Calculate aspect ratio and fit image within the container's size
                    const originalWidth = imgElement.naturalWidth;
                    const originalHeight = imgElement.naturalHeight;
                    const aspectRatio = originalWidth / originalHeight;

                    // Determine the correct drawing size and position to maintain aspect ratio
                    let drawWidth, drawHeight;
                    if (containerWidth / containerHeight > aspectRatio) {
                        drawHeight = containerHeight;
                        drawWidth = drawHeight * aspectRatio;
                    } else {
                        drawWidth = containerWidth;
                        drawHeight = drawWidth / aspectRatio;
                    }

                    // Calculate scale factor based on canvas size change
                    const scaleFactor = canvasWidth / 500; // Assuming original canvas was 1000x1000
                    const scaledWidth = drawWidth * scaleFactor;
                    const scaledHeight = drawHeight * scaleFactor;

                    // Calculate the final position on the canvas using the image's own position
                    const drawX = (left + (containerWidth - drawWidth) / 2) * scaleFactor; // Centering the image
                    const drawY = (top + (containerHeight - drawHeight) / 2) * scaleFactor; // Centering the image   
                    
                    // Draw the image onto the canvas at the calculated position and size
                    ctx.drawImage(imgElement, drawX, drawY, scaledWidth, scaledHeight);

                    imagesLoaded++;  // Increment the count of loaded images

                    // Check if all images are loaded and drawn 
                    // and save with compression to minimal size (> 1MB)
                    checkAllImagesLoaded();
                };
            });


        });
    </script>

</body>
{% endblock %}
</html>